/**
 * @file globals.cpp
 * @brief Implementation of global variables and utility functions
 * 
 * This file contains:
 * - Global variable definitions used across the engine
 * - Mesh conversion utilities for procedural geometry
 * - 3D model loading from Assimp format
 * - Physics type conversions between Bullet3 and GLM
 * - Geometric calculation implementations
 */

// Enable STB_IMAGE implementation (for loading image files)
#define STB_IMAGE_IMPLEMENTATION
#include "stb/stb_image.h"

// Enable PAR_SHAPES implementation (for procedural geometry generation)
#define PAR_SHAPES_IMPLEMENTATION
#include "par_shapes.h"

#include "globals.hpp"

/**
 * @brief GLFW error callback - prints errors to stderr
 * 
 * This callback is registered with GLFW to handle window and context errors.
 * 
 * @param error GLFW error code
 * @param description Human-readable error description
 */
void glfw_errorCallback(int error, const char* description)
{
    fprintf(stderr, "GLFW error %d: %s\n", error, description);
};

// === Global Variable Definitions ===

// Core engine state
tmt::render::RendererInfo* renderer;
std::vector<tmt::debug::DebugCall> debugCalls;
std::vector<tmt::render::DrawCall> drawCalls;
std::vector<tmt::light::Light*> lights;
std::vector<std::function<void()>> debugFuncs;
glm::vec2 mousep;
glm::vec2 mousedelta;
glm::vec2 mousescrl;
int lastKey;
tmt::render::Camera* mainCamera;
tmt::obj::Scene* mainScene = nullptr;
tmt::render::Shader* defaultShader;
tmt::engine::Application* application;

// Time tracking
int counterTime = 0;
float deltaTime = 1.0f / 60.0f;  // Initialize to 60 FPS
float lastTime = 0;
u32 frameTime = 0;

// Shader uniform handles
tmgl::UniformHandle orthoHandle;
tmgl::UniformHandle timeHandle;
tmgl::UniformHandle vposHandle;
tmgl::UniformHandle animHandle;
tmt::light::LightUniforms* lightUniforms;
bool subHandlesLoaded = false;

// Primitive meshes cache
std::map<tmt::prim::PrimitiveType, tmt::render::Mesh*> primitives;

/**
 * @brief Convert a par_shapes procedural mesh to engine format
 * 
 * This function takes a mesh generated by the par_shapes library
 * (spheres, cubes, cylinders, etc.) and converts it to the engine's
 * vertex format with positions, normals, and UV coordinates.
 * 
 * The function:
 * 1. Computes normals if not present
 * 2. Allocates arrays for vertices and indices
 * 3. Copies position, normal, and UV data
 * 4. Returns everything as a tuple
 * 
 * @param mesh The par_shapes mesh to convert
 * @return Tuple of (vertex array pointer, index array pointer, vertex count, index count)
 */
std::tuple<tmt::render::Vertex*, u16*, u16, u16> convertMesh(par_shapes_mesh* mesh)
{
    // Compute normals if the mesh doesn't have them
    par_shapes_compute_normals(mesh);

    // Get counts
    var vertexCount = mesh->npoints;
    var indexCount = mesh->ntriangles * 3;

    // Allocate memory for vertices and indices
    var vertices = new tmt::render::Vertex[vertexCount];
    var indices = new uint16_t[indexCount];

    // Populate vertices with position, normal, and UV data
    for (int i = 0; i < vertexCount; ++i)
    {
        tmt::render::Vertex& vertex = vertices[i];

        // Extract position from mesh data (stored as flat array: x,y,z,x,y,z,...)
        vertex.position = glm::vec3(
            mesh->points[3 * i + 0],
            mesh->points[3 * i + 1],
            mesh->points[3 * i + 2]
            );

        // Extract normal if available
        if (mesh->normals)
        {
            vertex.normal = glm::vec3(
                mesh->normals[3 * i + 0],
                mesh->normals[3 * i + 1],
                mesh->normals[3 * i + 2]
                );
        }

        // Extract UV coordinates if available
        if (mesh->tcoords)
        {
            vertex.uv0 = glm::vec2(
                mesh->tcoords[2 * i + 0],
                mesh->tcoords[2 * i + 1]
                );
        }
    }

    // Populate indices (3 indices per triangle)
    for (int i = 0; i < mesh->ntriangles; ++i)
    {
        indices[3 * i + 0] = mesh->triangles[3 * i + 0];
        indices[3 * i + 1] = mesh->triangles[3 * i + 1];
        indices[3 * i + 2] = mesh->triangles[3 * i + 2];
    }
    
    return {vertices, indices, vertexCount, indexCount};
};

tmt::obj::CameraObject* mainCameraObject;

/**
 * @brief Recursively load a 3D object hierarchy from an Assimp scene node
 * 
 * This function is called during model loading to convert Assimp's scene graph
 * into the engine's object hierarchy. It:
 * 1. Creates a new Object with the node's name
 * 2. Extracts and converts the transform (position, rotation, scale)
 * 3. Creates MeshObjects for each mesh attached to the node
 * 4. Recursively loads all child nodes
 * 5. Sets up parent-child relationships
 * 
 * @param node The Assimp scene node to load
 * @param info Scene information containing meshes, materials, and the scene pointer
 * @return tmt::obj::Object* The loaded object with all children attached
 */
tmt::obj::Object* LoadObject(aiNode* node, tmt::obj::ObjectLoader::SceneInfo info)
{
    // Create new object with the node's name
    var obj = new tmt::obj::Object();
    obj->name = node->mName.C_Str();

    // Get the node's transformation matrix
    var transform = node->mTransformation;
    aiVector3D p, r, s;  // position, rotation (Euler), scale

    // Decompose the matrix into position, rotation, and scale
    transform.Decompose(s, r, p);

    // Convert Assimp's rotation from radians to degrees
    r.x = glm::degrees(r.x);
    r.y = glm::degrees(r.y);
    r.z = glm::degrees(r.z);

    // Convert Assimp types to GLM types and set object transform
    obj->position = tmt::math::convertVec3(p);
    obj->rotation = tmt::math::convertVec3(r);
    obj->scale = tmt::math::convertVec3(s);

    // Load all meshes attached to this node
    for (int i = 0; i < node->mNumMeshes; ++i)
    {
        var meshIndex = node->mMeshes[i];

        // Create a MeshObject for each mesh
        var msh = new tmt::obj::MeshObject();
        msh->mesh = info.meshes[meshIndex];
        
        // Get the material for this mesh from the scene
        msh->material = info.materials[info.scene->mMeshes[meshIndex]->mMaterialIndex];

        // Attach mesh object as child of this object
        msh->SetParent(obj);
    }

    // Recursively load all child nodes
    for (int i = 0; i < node->mNumChildren; ++i)
    {
        var cobj = LoadObject(node->mChildren[i], info);

        // Attach child object to this object
        cobj->SetParent(obj);
    }

    return obj;
};
// === Input State Tracking ===
std::vector<int> mstates(8);      // Mouse button states (up to 8 buttons)
std::vector<int> kstates;         // Keyboard key states (dynamically sized)
std::vector<int> gstates;         // Gamepad button states (dynamically sized)

// === Physics System State ===
btDiscreteDynamicsWorld* dynamicsWorld;                  // Bullet physics world
std::vector<btRigidBody*> physicalBodies;                // Bullet rigid bodies
std::vector<btCollisionShape*> collisionObjs;            // Bullet collision shapes
std::vector<tmt::physics::PhysicsBody*> bodies;          // Engine physics body wrappers
std::vector<tmt::particle::Particle*> managed_particles; // Active particles
bool doneFirstPhysicsUpdate;                             // First update flag

// === Physics Type Conversion Functions ===

/**
 * @brief Convert Bullet3 vector to GLM vec3
 * @param v Bullet vector
 * @return glm::vec3 Equivalent GLM vector
 */
glm::vec3 convertVec3(btVector3 v)
{
    return glm::vec3{v.x(), v.y(), v.z()};
};

/**
 * @brief Convert GLM vec3 to Bullet3 vector
 * @param v GLM vector
 * @return btVector3 Equivalent Bullet vector
 */
btVector3 convertVec3(glm::vec3 v)
{
    return btVector3(v.x, v.y, v.z);
};

/**
 * @brief Convert Bullet3 quaternion to Euler angles (degrees)
 * 
 * Extracts Euler angles from a quaternion in ZYX order (yaw, pitch, roll).
 * 
 * @param q Bullet quaternion
 * @return glm::vec3 Euler angles in degrees (x=pitch, y=yaw, z=roll)
 */
glm::vec3 convertQuatEuler(btQuaternion q)
{
    float x, y, z;

    // Get Euler angles in ZYX order from quaternion
    q.getEulerZYX(x, y, z);

    return (glm::vec3{x, y, z});
};

/**
 * @brief Convert Euler angles (degrees) to Bullet3 quaternion
 * 
 * Note: The conversion order appears to be YXZ based on the constructor call.
 * 
 * @param q Euler angles in degrees
 * @return btQuaternion Equivalent Bullet quaternion
 */
btQuaternion convertQuat(glm::vec3 q)
{
    float x, y, z;

    // Convert degrees to radians
    var qu = radians(q);

    x = qu.x;
    y = qu.y;
    z = qu.z;

    // Note: Order is y, x, z (not standard x, y, z)
    return btQuaternion(y, x, z);
};

/**
 * @brief Convert Bullet3 quaternion to GLM quaternion
 * @param q Bullet quaternion
 * @return glm::quat Equivalent GLM quaternion (note: different component order)
 */
glm::quat convertQuat(btQuaternion q) 
{ 
    return glm::quat(q.w(), q.x(), q.y(), q.z()); 
}

/**
 * @brief Convert GLM quaternion to Bullet3 quaternion
 * @param q GLM quaternion
 * @return btQuaternion Equivalent Bullet quaternion
 */
btQuaternion convertQuat(glm::quat q)
{
    return btQuaternion(q.x, q.y, q.z, q.w);
};

/**
 * @brief Apply a physics transform to a physics body
 * 
 * Updates the engine's physics body wrapper with the transform calculated
 * by the Bullet physics simulation. Handles two modes:
 * - Self mode: Updates the body's own position/rotation
 * - Parent mode: Updates the parent object's position/rotation
 * 
 * @param body The physics body to update
 * @param transform The transform from Bullet physics simulation
 */
void ApplyTransform(tmt::physics::PhysicsBody* body, btTransform transform)
{
    // Skip if body is not active
    if (!body->active)
        return;

    var parent = body->parent;
    
    if (body->transRelation == tmt::physics::PhysicsBody::Self)
    {
        // Update body's own position directly
        var p = body->position;
        body->position = convertVec3(transform.getOrigin());
    }
    else
    {
        // Update parent object's position and rotation
        var p = parent->position;
        var r = parent->rotation;

        parent->position = convertVec3(transform.getOrigin());

        parent->rotation = convertQuatEuler(transform.getRotation());
    }
};

/**
 * @brief Check if a 3D point lies inside a triangle
 * 
 * Uses barycentric coordinate method to determine if a point is within
 * the bounds of a triangle. This is useful for:
 * - Ray-triangle intersection tests
 * - Determining which triangle a point projects onto
 * - Mesh picking and selection
 * 
 * @param p The point to test
 * @param a First triangle vertex
 * @param b Second triangle vertex
 * @param c Third triangle vertex
 * @param scale Optional scale factor applied to vertices (default: 1,1,1)
 * @return true if point is inside the triangle, false otherwise
 */
bool pointInTriangle(const glm::vec3& p, const glm::vec3& a, const glm::vec3& b, const glm::vec3& c,
                     glm::vec3 scale)
{
    // Calculate edge vectors from vertex a
    glm::vec3 v0 = b - a;
    glm::vec3 v1 = c - a;
    glm::vec3 v2 = p - a;

    // Compute dot products for barycentric calculation
    float dot00 = glm::dot(v0, v0);
    float dot01 = glm::dot(v0, v1);
    float dot02 = glm::dot(v0, v2);
    float dot11 = glm::dot(v1, v1);
    float dot12 = glm::dot(v1, v2);

    // Calculate barycentric coordinates
    float invDenom = 1.0f / (dot00 * dot11 - dot01 * dot01);
    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    float v = (dot00 * dot12 - dot01 * dot02) * invDenom;

    // Check if point is inside triangle
    // Point is inside if: u >= 0, v >= 0, and u + v <= 1
    var bl = (u >= 0) && (v >= 0) && (u + v <= 1);

    // Debug visualization (commented out by default)
    if (bl)
    {
        //tmt::debug::Gizmos::DrawSphere(a, 1.f);
        //tmt::debug::Gizmos::DrawSphere(b, 1.f);
        //tmt::debug::Gizmos::DrawSphere(c, 1.f);
        //tmt::debug::Gizmos::DrawSphere(p, 1.f);
    }

    return bl;
};

/**
 * @brief Calculate barycentric coordinates of a point relative to a triangle
 * 
 * Barycentric coordinates (u, v, w) represent any point in the triangle's plane
 * as a weighted combination of the triangle's vertices:
 *   P = u*A + v*B + w*C  where u + v + w = 1
 * 
 * These coordinates are useful for:
 * - Interpolating vertex attributes (colors, normals, UVs) across a triangle
 * - Determining if a point is inside a triangle (all coordinates >= 0)
 * - Calculating smooth shading values
 * 
 * @param p The point to calculate coordinates for
 * @param a First triangle vertex
 * @param b Second triangle vertex
 * @param c Third triangle vertex
 * @param scale Optional scale factor applied to vertices (default: 1,1,1)
 * @return glm::vec3 Barycentric coordinates (u, v, w)
 */
glm::vec3 barycentricCoordinates(const glm::vec3& p, const glm::vec3& a, const glm::vec3& b, const glm::vec3& c,
                                 glm::vec3 scale)
{
    // Calculate edge vectors from vertex a
    glm::vec3 v0 = b - a;
    glm::vec3 v1 = c - a;
    glm::vec3 v2 = p - a;

    // Compute dot products needed for barycentric formula
    float dot00 = glm::dot(v0, v0);
    float dot01 = glm::dot(v0, v1);
    float dot02 = glm::dot(v0, v2);
    float dot11 = glm::dot(v1, v1);
    float dot12 = glm::dot(v1, v2);

    // Calculate barycentric coordinates u and v
    float invDenom = 1.0f / (dot00 * dot11 - dot01 * dot01);
    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    float v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    
    // Calculate w (remaining weight) - ensures u + v + w = 1
    float w = 1.0f - u - v;

    var bary = glm::vec3{u, v, w};

    //bary -= glm::vec3{ 0.5 };
    //bary = -bary;

    // Debug visualization when point is inside triangle (all coords >= 0)
    if (u >= 0 && v >= 0 && w >= 0)
    {
        tmt::debug::Gizmos::DrawSphere(a, 1.f);
        tmt::debug::Gizmos::DrawSphere(b, 1.f);
        tmt::debug::Gizmos::DrawSphere(c, 1.f);
        tmt::debug::Gizmos::DrawSphere(p, 1.f);
        tmt::debug::Gizmos::DrawSphere(bary, 1.f);
    }

    return bary;
};

/**
 * @brief Create a Bullet3 collision shape from collider initialization info
 * 
 * Factory function that creates the appropriate Bullet physics collision shape
 * based on the type specified in the init info. Supports:
 * - Box: Rectangular prism collision
 * - Sphere: Spherical collision
 * - Capsule: Cylinder with hemispherical caps (good for characters)
 * - Mesh: Triangle mesh collision (expensive but accurate)
 * 
 * @param i Collider initialization information specifying:
 *          - Shape type (Box, Sphere, Capsule, Mesh)
 *          - Dimensions (bounds for box, radius for sphere, etc.)
 *          - Mesh data (for mesh colliders)
 * @return btCollisionShape* The created Bullet collision shape (caller owns memory)
 */
btCollisionShape* ShapeFromInfo(tmt::physics::ColliderInitInfo i)
{
    btCollisionShape* shape;
    
    switch (i.s)
    {
        case tmt::physics::Box:
            // Box shape - bounds divided by 2 because Bullet uses half-extents
            shape = new btBoxShape(convertVec3(i.bounds / 2.f));
            break;
            
        case tmt::physics::Sphere:
            // Sphere shape - simple radius
            shape = new btSphereShape(i.radius);
            break;
            
        case tmt::physics::Capsule:
            // Capsule shape - radius and height (good for character controllers)
            shape = new btCapsuleShape(i.radius, i.height);
            break;
            
        case tmt::physics::Mesh:
        {
            // Triangle mesh shape - most accurate but most expensive
            // Copy indices from mesh
            auto indices = new int[i.mesh->indexCount];
            for (int j = 0; j < i.mesh->indexCount; ++j)
            {
                indices[j] = i.mesh->indices[j];
            }

            // Copy vertices (positions only) from mesh
            auto vertices = new glm::vec3[i.mesh->vertexCount];
            for (int j = 0; j < i.mesh->vertexCount; ++j)
            {
                var vert = i.mesh->vertices[j].position;
                vertices[j] = vert;
            }

            // Create Bullet's indexed triangle array structure
            auto indexVertexArray = new btTriangleIndexVertexArray(
                i.mesh->indexCount / 3,                      // Number of triangles
                &indices[0],                                  // Pointer to index array
                sizeof(int) * 3,                              // Stride between triangle indices
                i.mesh->vertexCount,                          // Number of vertices
                reinterpret_cast<float*>(&vertices[0]),      // Pointer to vertex array
                sizeof(glm::vec3)                             // Stride between vertices
                );

            // Create BVH (Bounding Volume Hierarchy) triangle mesh shape
            // This provides efficient collision detection for complex meshes
            shape = new btBvhTriangleMeshShape(indexVertexArray, true);
        }
        break;
        
        default:
            break;
    }

    return shape;
};
